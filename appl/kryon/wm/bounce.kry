use math;

# Type declarations for bouncing balls
struct Realpoint {
    x: real;
    y: real;
};

struct Line {
    p1: Realpoint;
    p2: Realpoint;
};

# Constants
const BALLSIZE = 4;
const ZERO = 1e-6;

# Global state
var lines: Line[];
var drawing: int = 0;
var lineStart: Realpoint;

# Physics functions
fn makeunit(v: Realpoint): Realpoint {
    mag: real = Math->sqrt(v.x * v.x + v.y * v.y);
    return Realpoint(v.x / mag, v.y / mag);
}

fn boing(av: Realpoint, b: Line): Realpoint {
    fx: real = b.p2.x - b.p1.x;
    fy: real = b.p2.y - b.p1.y;
    d: real = Math->atan2(fy, fx) * 2.0 - Math->atan2(av.y, av.x);
    return Realpoint(Math->cos(d), Math->sin(d));
}

# Mouse event handlers
fn handleMouseDown(x: int, y: int, button: int) {
    drawing = 1;
    lineStart = Realpoint(real x, real y);
}

fn handleMouseUp(x: int, y: int, button: int) {
    if (drawing) {
        lines = Line(lineStart, Realpoint(real x, real y)) :: lines;
        drawing = 0;
    }
}

fn handleMouseMove(x: int, y: int) {
    # Track mouse movement while drawing
}

# Main animation callback using Graphics API
fn animate(ctx: Graphics, t: int) {
    # Clear screen with light blue background
    ctx.clear("#d4f7f4");

    # Set stroke color for lines
    ctx.stroke(Color.black);
    ctx.setlinewidth(3);

    # Draw lines
    for (l in lines) {
        ctx.line(int l.p1.x, int l.p1.y, int l.p2.x, int l.p2.y);
    }
}

# Window declaration
Window {
    title = "Bounce"
    width = 400
    height = 400
    type = Appl

    Canvas {
        onDraw = animate @ 30000
    }

    onMouseDown = handleMouseDown
    onMouseUp = handleMouseUp
    onMouseMove = handleMouseMove
}
